#pragma once

const uint32_t float_exponentMask = 0x40000000;
const uint32_t float_mantissaMask = 0x007fffff;

const uint32_t rng_32bit_multiplier = 1664525;
const uint32_t rng_32bit_increment = 1013904223;

const uint64_t rng_64bit_multiplier = 6364136223846793005UL;
const uint64_t rng_64bit_increment = 1442695040888963407UL;


class Rng
{
    uint_v state0;
    uint_v state1;

    float_v scale_full;
    float_v scale_half;


public:
    Rng()
    {
        SlowSeed((char*)&state1, sizeof(state1));
        SlowSeed((char*)&state0, sizeof(state0));
    }

    static void SlowSeed(char* buf, size_t len);






    inline void SetFloatScale(float scale)
    {
        scale_full = scale;
        scale_half = scale / 2;
    }

    /// <summary>
    /// 6 RDTSC cycles, including a post-exit summation and loop construct
    /// </summary>
    inline float_v NextScaledFloats()
    {
        state1 = Next_Xorshift32(state1);
        return NextScaledFloats(state1);
    }

    inline float_v NextScaledFloats(uint_v x)
    {
        float_v rawFloats1 = AsFloatFast<float_v, uint_v>(x);

        auto retval = rawFloats1 * scale_half - scale_full;

        return retval;
    }

    /// <summary>
    /// 9 RDTSC cycles, including a post-exit summation and loop construct
    /// </summary>
    /// <param name="first"></param>
    /// <param name="second"></param>
    inline void NextScaledFloats(float_v* first, float_v* second)
    {
        state1 = Next_Xorshift32(state1);
        state0 = Next_Xorshift32(state0);

        float_v rawFloats1 = AsFloatFast<float_v, uint_v>(state1);
        float_v rawFloats2 = AsFloatFast<float_v, uint_v>(state0);

        *first = rawFloats1 * scale_half - scale_full;
        *second = rawFloats2 * scale_half - scale_full;
    }

    inline uint_t Next31()
    {
        uint_t* pFirst = (uint_t*)&state1;

        *pFirst = Next_Xorshift32(*pFirst);

        // remove the fact that Zero can't be generated by halving the range, thus "Next31"
        return *pFirst >> 1;
    }

    template<class Tfloat, class Tuint>
    inline static Tfloat AsFloat(Tuint val) { return AsFloatFast<Tfloat, Tuint>(val >> 1); }

    template<class Tfloat, class Tuint>
    inline static Tfloat AsFloatFast(Tuint val)
    {
        auto tmp = (val & float_mantissaMask) | float_exponentMask;
        Tfloat* ptr = (Tfloat*)&tmp;
        return *ptr;
    }

    template<class Tfloat>
    inline Tfloat NextFloat(Tfloat scale = 1.0f)
    {
        state0 = Next_Xorshift32(state0);
        Tfloat nextRawFloat = AsFloatFast<Tfloat>(state0);

        Tfloat tmp1 = scale / 2;
        Tfloat tmp3 = nextRawFloat * tmp1 - scale;

        return tmp3;
    }

    void Fill(void* buffer, int count)
    {
        static uint64_t fillState = __rdtsc();

        size_t len = count >> 3; // 64 bits at a time (right 3 for bits/byte, left 6 for bytes_in_64bits

        uint64_t* ptr = (uint64_t*)buffer;
        for (size_t i = 0; i < len; i++)
        {
            fillState = Next_Xorshift64(fillState);
            *ptr++ = fillState;
        }
    }

    void NextVectorTriplet(float_v*& scaled, uint_v*& bitidx)
    {
        state0 ^= state0 << 13;
        state1 ^= state1 << 13;

        *(bitidx++) = state0;
        *(scaled++) = NextScaledFloats(state1);

        state0 ^= state0 >> 17;
        state1 ^= state1 >> 17;

        *(bitidx++) = state0;
        *(scaled++) = NextScaledFloats(state1);

        state0 ^= state0 << 5;
        state1 ^= state1 << 5;

        *(bitidx++) = state0;
        *(scaled++) = NextScaledFloats(state1);
    }

    template<class T>
    inline static T Next_Xorshift32(T state)
    {
        state ^= (state << 13);
        state ^= (state >> 17);
        state ^= (state << 5);
        return state;
    }

    template<class T>
    inline static T Next_Xorshift64(T state)
    {
        state ^= (state >> 13);
        state ^= (state << 7);
        state ^= (state >> 17);
        return state;
    }

    template<class T>
    inline static T Next_Linear32(T rngState)
    {
        return rngState * rng_32bit_multiplier + rng_32bit_increment;
    }

    template<class T>
    inline static T Next_Linear64(T rngState)
    {
        return rngState * rng_64bit_multiplier + rng_64bit_increment;
    }
};

